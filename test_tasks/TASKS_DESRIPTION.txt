

0. Установить среду для разработки:
	- Установить Docker
	- Установить Postgres в контейнере
	- Установить IDE (например PyCharm)
	- Создать Python проект
	- Подключить стандартную библиотеку для логгирования и настроить к ней конфиг 
		(стандартные настройки для вывода лога в файл с уровнем DEBUG подойдут)
	- Подключить PANDAS библиотеку
	- Подключить необходимые библиотеки для работы с файлами и парсинга JSON
	
1. Нормализация данных и построение справочника
	- Проанализировать данные в файле.
	- Подготовить нормализованную схему для загрузки в нее данных (EMPLOYEES, DEPARTMENTS, SYONYMS)
	- Написать программу на Python, которая:
		- считывает входной файл в датафрейм(ы)
		- обрабатывает данные
			-(!обратить внимание на то что DEPARTMENT c ID = 1 - вложенная копия, нас интересует его последняя версия. 
			- последней считается та версия, которая вложена в родительский объект с максимальным "@rid")
		- загружает данные в Postgres
		
2. Обработка ссылок/внешних ключей и вложенных объектов + дамми объект
	- Проанализировать данные в файле.
	- Подготовить нормализованную схему для загрузки в нее данных (EMPLOYEES, DEPARTMENTS)
		(для обеих таблиц создать поле ID - primary key, целочисленный генерируемый ключь. 
		для EMPLOYEES - поля DEPARTMENT_1,DEPARTMENTS_2,DEPARTMENT_3, - foreign key ссылающиеся на сгенерированный ID таблицы DEPARTMENTS)
	- Написать программу на Python, которая:
		- считывает входной файл в датафрейм(ы)
		- обрабатывает данные
			- загружает валидные данные. Валидными данными считаются записи о сорудниках у которых:
				- "NAME": "DummyEmployee"
				- присутствуют все 3 поля DEPARTMENT_1,DEPARTMENTS_2,DEPARTMENT_3
				- в этих полях либо существующий в справочнике DEPARTMENTS "@rid" либо вложенный целый объект,с аттрибутом NAME существующем в справочнике DEPARTMENTS
				(комбинация "@rid" и вложенного объекта так же считается валидной если по ним можно построить связь со српавочником DEPARTMENTS)
			- записывает невалидные данные в лог файл (достаточно будет в лог написать поле "@rid")			
		- загружает данные в Postgres
		
3. Множественные источники тех же данных, удаление точных дубликатов, выбор последней версии в рамках источника, унификация структур, выбор версии объекта в зависимости от приоритета источника
	- Проанализировать данные в файле.
	- Подготовить нормализованную схему для загрузки в нее данных (EMPLOYEES)
		(Таблица должна содержать максимальный набор уникальных полей
		 Обратить внимание что поля DEPARTMENT_1,DEPARTMENT,DEP - это одно поле в целевой таблице (его обработка не в рамках этого задания))
	- Написать программу на Python, которая:
			- считывает входные файлы в датафрейм(ы)
			- обрабатывает данные
				- удаляет точные дублиаты объектов
				- для объектов в рамках одного источника - выбирает последнюю версию объекта
				- в результате объединяет данные из всех 3 источников в один датафрейм
				- выбирает из получившегося датафрейма версию в соответствии с приоритетом источника.
					(приоритет источников: source 1, source 2, source 3)
			- загружает данные в Postgres
			
4. Вложенный массив, назначение порядкового номера
	- Проанализировать данные в файле.
	- Подготовить нормализованную схему для загрузки в нее данных (DEPARTMENS,SUB_DEPARTMENTS)
		Использовать NAME как primary/fireign key
		Таблица SUB_DEPARTMENTS:(DEPARTMENS_NAME(FK),NAME(PK),DESCRIPTION,ORDER)		
	- Написать программу на Python, которая:
			- считывает входные файлы в датафрейм(ы)
			- обрабатывает данные
				- при загрузке SUB_DEPARTMENTS - рассчитать значение ORDER - как порядковый номер элемента, на основе следющего маппинга/приоритета:
					B
					A
					C
					D
					E
				- отсутствующие элементы не должны создавать дыры в нумерации ORDER
				- элементы С - имеют целочисленный суффикс, его значение должно быть учтено при рвассчете ORDER
				Пример результата для "NAME": "Department 4":
					1-A
					2-C1
					3-C2
					4-C3
					5-C5
					6-C7
					7-D
					8-E	
				Пример результата для "NAME": "Department 3"
					1-B
					2-A
					3-C1
					4-C2
					5-D
			- загружает данные в Postgres			